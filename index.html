<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Immersive Visual Lab - 3D & Fluid</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: rgba(30, 41, 59, 0.3); }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(99, 102, 241, 0.6); border-radius: 3px; }
        body { margin: 0; overflow: hidden; background-color: #0f172a; overscroll-behavior: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- ICONS ---
        const IconCube = ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"/><polyline points="3.27 6.96 12 12.01 20.73 6.96"/><line x1="12" y1="22.08" x2="12" y2="12"/></svg>;
        const IconStar = ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>;
        const IconCircle = ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>;
        const IconDroplet = ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/></svg>;
        const IconWind = ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M17.7 7.7a2.5 2.5 0 1 1 1.8 4.3H2"/><path d="M9.6 4.6A2 2 0 1 1 11 8H2"/><path d="M12.6 19.4A2 2 0 1 0 14 16H2"/></svg>;
        const IconMusic = ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/></svg>;
        
        // Common UI Icons
        const IconVolume2 = ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>;
        const IconVolumeX = ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" x2="17" y1="9" y2="15"/><line x1="17" x2="23" y1="9" y2="15"/></svg>;
        const IconPlay = ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" strokeWidth="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>;
        const IconSettings = ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.39a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>;
        const IconSliders = ({size=24}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="4" x2="4" y1="21" y2="14"/><line x1="4" x2="4" y1="10" y2="3"/><line x1="12" x2="12" y1="21" y2="12"/><line x1="12" x2="12" y1="8" y2="3"/><line x1="20" x2="20" y1="21" y2="16"/><line x1="20" x2="20" y1="12" y2="3"/><line x1="2" x2="6" y1="14" y2="14"/><line x1="10" x2="14" y1="8" y2="8"/><line x1="18" x2="22" y1="16" y2="16"/></svg>;

        const DEFAULT_PARAMS = {
            raycaster: {
                fov: { value: 60, min: 30, max: 90, label: 'FOV' },
                speed: { value: 3, min: 1, max: 10, label: 'Move Speed' }
            },
            starfield: {
                speed: { value: 10, min: 1, max: 50, label: 'Warp Speed' },
                count: { value: 400, min: 100, max: 1000, label: 'Star Count' }
            },
            tunnel: {
                speed: { value: 2, min: 0.5, max: 5, label: 'Travel Speed' },
                twist: { value: 0, min: -2, max: 2, label: 'Twist' }
            },
            ripples: {
                damping: { value: 0.96, min: 0.9, max: 0.99, label: 'Damping' },
                frequency: { value: 1, min: 0, max: 5, label: 'Rain Rate' }
            },
            fluid: {
                dissipation: { value: 0.98, min: 0.9, max: 1.0, label: 'Dissipation' },
                vorticity: { value: 20, min: 0, max: 50, label: 'Vorticity' }
            },
            visualizer: {
                smoothing: { value: 0.8, min: 0.1, max: 0.99, label: 'Smoothing' },
                boost: { value: 2.0, min: 1.0, max: 5.0, label: 'Visual Boost' }
            }
        };

        // --- EFFECT IMPLEMENTATIONS ---

        // 1. RAYCASTER (Unchanged)
        class RaycasterEffect {
            constructor(w, h) { this.w = w; this.h = h; this.map = []; this.p = {x:3.5, y:3.5, dir:0, plane:{x:0, y:0.66}}; this.init(); }
            init() {
                const m = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
                this.map = m; this.p = {x:3.5, y:3.5, dir:0};
            }
            resize(w, h) { this.w=w; this.h=h; }
            update(mouse, params) {
                const speed = (params.speed || 3) * 0.01; const rotSpeed = 0.03;
                const center = this.w / 2; const dx = (mouse.x - center) / center;
                this.p.dir += dx * rotSpeed;
                const moveStep = speed;
                const newX = this.p.x + Math.cos(this.p.dir) * moveStep;
                const newY = this.p.y + Math.sin(this.p.dir) * moveStep;
                if(this.map[Math.floor(newY)*16 + Math.floor(newX)] === 0) { this.p.x = newX; this.p.y = newY; } else { this.p.dir += Math.PI/2; }
            }
            draw(ctx, params) {
                ctx.fillStyle = '#1e1b4b'; ctx.fillRect(0,0,this.w, this.h/2);
                ctx.fillStyle = '#312e81'; ctx.fillRect(0,this.h/2,this.w, this.h/2);
                const fov = (params.fov || 60) * (Math.PI/180); const halfFov = fov/2;
                const numRays = Math.floor(this.w / 2); const stripWidth = Math.ceil(this.w / numRays);
                for(let i=0; i<numRays; i++) {
                    const rayAngle = (this.p.dir - halfFov) + (i/numRays)*fov;
                    const eyeX = Math.cos(rayAngle); const eyeY = Math.sin(rayAngle);
                    let hitWall = false; let distance = 0;
                    while(!hitWall && distance < 20) {
                        distance += 0.1;
                        let testX = Math.floor(this.p.x + eyeX * distance);
                        let testY = Math.floor(this.p.y + eyeY * distance);
                        if(testX < 0 || testX >= 16 || testY < 0 || testY >= 16 || this.map[testY*16 + testX] === 1) hitWall = true;
                    }
                    const z = distance * Math.cos(rayAngle - this.p.dir);
                    const ceiling = this.h/2 - this.h/z; const wallHeight = this.h - 2*ceiling;
                    const shade = Math.max(0, 255 - distance*15);
                    ctx.fillStyle = `rgb(${shade}, ${shade*0.8}, ${shade*1.5})`;
                    ctx.fillRect(i*stripWidth, ceiling, stripWidth, wallHeight);
                }
                ctx.fillStyle = "#fff"; ctx.textAlign="center"; ctx.fillText("MOUSE LEFT/RIGHT TO TURN", this.w/2, 50);
            }
        }

        // 2. STARFIELD (Unchanged)
        class StarfieldEffect {
            constructor(w, h) { this.w = w; this.h = h; this.stars = []; this.init(); }
            init() { this.stars = []; }
            resize(w, h) { this.w=w; this.h=h; }
            update(mouse, params) {
                const count = params.count || 400; const speed = params.speed || 10;
                while(this.stars.length < count) this.stars.push({x: (Math.random()-0.5)*this.w*2, y: (Math.random()-0.5)*this.h*2, z: Math.random()*this.w});
                while(this.stars.length > count) this.stars.pop();
                const cx = (mouse.x - this.w/2) * 2; const cy = (mouse.y - this.h/2) * 2;
                this.stars.forEach(s => {
                    s.z -= speed; s.x -= cx * 0.01; s.y -= cy * 0.01;
                    if(s.z <= 1) { s.z = this.w; s.x = (Math.random()-0.5)*this.w*2; s.y = (Math.random()-0.5)*this.h*2; }
                });
            }
            draw(ctx) {
                ctx.fillStyle = '#000'; ctx.fillRect(0,0,this.w, this.h); ctx.fillStyle = '#fff';
                const cx = this.w/2; const cy = this.h/2;
                this.stars.forEach(s => {
                    const sx = (s.x / s.z) * 100 + cx; const sy = (s.y / s.z) * 100 + cy; const size = (1 - s.z/this.w) * 4;
                    if(sx > 0 && sx < this.w && sy > 0 && sy < this.h) { ctx.globalAlpha = 1 - s.z/this.w; ctx.beginPath(); ctx.arc(sx, sy, size, 0, Math.PI*2); ctx.fill(); }
                });
                ctx.globalAlpha = 1;
            }
        }

        // 3. TUNNEL (Unchanged)
        class TunnelEffect {
            constructor(w, h) { this.w = w; this.h = h; this.t = 0; this.init(); }
            init() {}
            resize(w, h) { this.w=w; this.h=h; }
            update(mouse, params) { this.t += (params.speed || 2) * 0.05; }
            draw(ctx, params) {
                const cx = this.w/2; const cy = this.h/2; const twist = params.twist || 0; const step = 8;
                for(let r=50; r<Math.max(this.w, this.h); r+=step) {
                    const size = (r + (this.t*100)%step); const depth = size / Math.max(this.w, this.h);
                    ctx.save(); ctx.translate(cx, cy); ctx.rotate(depth * twist + this.t * 0.2);
                    ctx.strokeStyle = `hsla(${depth*360 + this.t*50}, 80%, 60%, ${depth})`; ctx.lineWidth = 2; ctx.strokeRect(-size/2, -size/2, size, size); ctx.restore();
                }
                ctx.fillStyle = 'rgba(15, 23, 42, 0.1)'; ctx.fillRect(0,0,this.w, this.h);
            }
        }

        // 4. RIPPLES (Unchanged)
        class RippleEffect {
            constructor(w, h) { this.w = w; this.h = h; this.cols = Math.floor(w/2); this.rows = Math.floor(h/2); this.buffer1 = []; this.buffer2 = []; this.init(); }
            init() { this.cols = Math.floor(this.w/4); this.rows = Math.floor(this.h/4); this.buffer1 = new Float32Array(this.cols * this.rows); this.buffer2 = new Float32Array(this.cols * this.rows); }
            resize(w, h) { this.w=w; this.h=h; this.init(); }
            update(mouse, params) {
                const damping = params.damping || 0.96; const rain = params.frequency || 1;
                if(Math.random()*10 < rain) { const rx = Math.floor(Math.random()*(this.cols-2))+1; const ry = Math.floor(Math.random()*(this.rows-2))+1; this.buffer1[rx + ry * this.cols] = 255; }
                if(mouse.isDown || (mouse.px !== mouse.x && Math.random()>0.5)) {
                    const mx = Math.floor((mouse.x/this.w)*this.cols); const my = Math.floor((mouse.y/this.h)*this.rows);
                    if(mx>1 && mx<this.cols-1 && my>1 && my<this.rows-1) this.buffer1[mx + my * this.cols] = 255;
                }
                for (let x = 1; x < this.cols - 1; x++) {
                    for (let y = 1; y < this.rows - 1; y++) {
                        const i = x + y * this.cols;
                        this.buffer2[i] = (this.buffer1[i-1] + this.buffer1[i+1] + this.buffer1[i-this.cols] + this.buffer1[i+this.cols]) / 2 - this.buffer2[i];
                        this.buffer2[i] *= damping;
                    }
                }
                let temp = this.buffer1; this.buffer1 = this.buffer2; this.buffer2 = temp;
            }
            draw(ctx) {
                const imgData = ctx.createImageData(this.cols, this.rows);
                for(let i=0; i<this.cols*this.rows; i++) {
                    let val = this.buffer1[i]; val = val > 255 ? 255 : val < 0 ? 0 : val;
                    const idx = i * 4; imgData.data[idx] = val; imgData.data[idx+1] = val + 50; imgData.data[idx+2] = val + 100; imgData.data[idx+3] = 255;
                }
                const tempCanvas = document.createElement('canvas'); tempCanvas.width = this.cols; tempCanvas.height = this.rows;
                tempCanvas.getContext('2d').putImageData(imgData, 0, 0); ctx.imageSmoothingEnabled = true; ctx.drawImage(tempCanvas, 0, 0, this.w, this.h);
            }
        }

        // 5. FLUID (Unchanged)
        class FluidEffect {
            constructor(w, h) { this.w = w; this.h = h; this.N = 40; this.iter = 4; this.size = (this.N+2)*(this.N+2); this.dt = 0.1; this.diff = 0; this.visc = 0; this.s = new Float32Array(this.size); this.density = new Float32Array(this.size); this.Vx = new Float32Array(this.size); this.Vy = new Float32Array(this.size); this.Vx0 = new Float32Array(this.size); this.Vy0 = new Float32Array(this.size); }
            init() {} resize(w, h) { this.w=w; this.h=h; }
            IX(x, y) { return x + (this.N + 2) * y; }
            addDensity(x, y, amount) { this.density[this.IX(x, y)] += amount; }
            addVelocity(x, y, amountX, amountY) { const index = this.IX(x, y); this.Vx[index] += amountX; this.Vy[index] += amountY; }
            lin_solve(b, x, x0, a, c) { const cRecip = 1.0/c; for(let k=0; k<this.iter; k++) { for(let j=1; j<=this.N; j++) { for(let i=1; i<=this.N; i++) { x[this.IX(i, j)] = (x0[this.IX(i, j)] + a * (x[this.IX(i+1, j)] + x[this.IX(i-1, j)] + x[this.IX(i, j+1)] + x[this.IX(i, j-1)])) * cRecip; } } this.set_bnd(b, x); } }
            project(velocX, velocY, p, div) { for(let j=1; j<=this.N; j++) { for(let i=1; i<=this.N; i++) { div[this.IX(i, j)] = -0.5 * (velocX[this.IX(i+1, j)] - velocX[this.IX(i-1, j)] + velocY[this.IX(i, j+1)] - velocY[this.IX(i, j-1)]) / this.N; p[this.IX(i, j)] = 0; } } this.set_bnd(0, div); this.set_bnd(0, p); this.lin_solve(0, p, div, 1, 4); for(let j=1; j<=this.N; j++) { for(let i=1; i<=this.N; i++) { velocX[this.IX(i, j)] -= 0.5 * (p[this.IX(i+1, j)] - p[this.IX(i-1, j)]) * this.N; velocY[this.IX(i, j)] -= 0.5 * (p[this.IX(i, j+1)] - p[this.IX(i, j-1)]) * this.N; } } this.set_bnd(1, velocX); this.set_bnd(2, velocY); }
            advect(b, d, d0, velocX, velocY) { let i0, i1, j0, j1; let dtx = this.dt * (this.N - 2); let dty = this.dt * (this.N - 2); let s0, s1, t0, t1; let tmp1, tmp2, x, y; for(let j=1; j<=this.N; j++) { for(let i=1; i<=this.N; i++) { tmp1 = dtx * velocX[this.IX(i, j)]; tmp2 = dty * velocY[this.IX(i, j)]; x = i - tmp1; y = j - tmp2; if(x<0.5) x=0.5; if(x>this.N+0.5) x=this.N+0.5; i0 = Math.floor(x); i1 = i0 + 1.0; if(y<0.5) y=0.5; if(y>this.N+0.5) y=this.N+0.5; j0 = Math.floor(y); j1 = j0 + 1.0; s1 = x - i0; s0 = 1.0 - s1; t1 = y - j0; t0 = 1.0 - t1; d[this.IX(i, j)] = s0 * (t0 * d0[this.IX(i0, j0)] + t1 * d0[this.IX(i0, j1)]) + s1 * (t0 * d0[this.IX(i1, j0)] + t1 * d0[this.IX(i1, j1)]); } } this.set_bnd(b, d); }
            set_bnd(b, x) { for(let i=1; i<=this.N; i++) { x[this.IX(i, 0)] = b==2 ? -x[this.IX(i, 1)] : x[this.IX(i, 1)]; x[this.IX(i, this.N+1)] = b==2 ? -x[this.IX(i, this.N)] : x[this.IX(i, this.N)]; } for(let j=1; j<=this.N; j++) { x[this.IX(0, j)] = b==1 ? -x[this.IX(1, j)] : x[this.IX(1, j)]; x[this.IX(this.N+1, j)] = b==1 ? -x[this.IX(this.N, j)] : x[this.IX(this.N, j)]; } x[this.IX(0, 0)] = 0.5 * (x[this.IX(1, 0)] + x[this.IX(0, 1)]); x[this.IX(0, this.N+1)] = 0.5 * (x[this.IX(1, this.N+1)] + x[this.IX(0, this.N)]); x[this.IX(this.N+1, 0)] = 0.5 * (x[this.IX(this.N, 0)] + x[this.IX(this.N+1, 1)]); x[this.IX(this.N+1, this.N+1)] = 0.5 * (x[this.IX(this.N, this.N+1)] + x[this.IX(this.N+1, this.N)]); }
            step() { this.diffuse(1, this.Vx0, this.Vx, this.visc); this.diffuse(2, this.Vy0, this.Vy, this.visc); this.project(this.Vx0, this.Vy0, this.Vx, this.Vy); this.advect(1, this.Vx, this.Vx0, this.Vx0, this.Vy0); this.advect(2, this.Vy, this.Vy0, this.Vx0, this.Vy0); this.project(this.Vx, this.Vy, this.Vx0, this.Vy0); this.diffuse(0, this.s, this.density, this.diff); this.advect(0, this.density, this.s, this.Vx, this.Vy); }
            diffuse(b, x, x0, diff) { const a = this.dt * diff * (this.N - 2) * (this.N - 2); this.lin_solve(b, x, x0, a, 1 + 6 * a); }
            update(mouse, params) {
                if (mouse.isDown) { const i = Math.floor((mouse.x/this.w)*this.N)+1; const j = Math.floor((mouse.y/this.h)*this.N)+1; if(i>0 && i<=this.N && j>0 && j<=this.N) { this.addDensity(i, j, 100); this.addVelocity(i, j, (mouse.x-mouse.px)*2, (mouse.y-mouse.py)*2); } }
                const decay = params.dissipation || 0.99; for(let i=0; i<this.size; i++) this.density[i] *= decay;
                this.step();
            }
            draw(ctx) {
                const cellW = this.w / this.N; const cellH = this.h / this.N;
                for (let i = 1; i <= this.N; i++) { for (let j = 1; j <= this.N; j++) { const d = this.density[this.IX(i, j)]; if(d > 0.1) { const c = Math.min(255, d * 255); ctx.fillStyle = `rgba(${c}, ${c*0.5}, ${c*0.8}, ${Math.min(1, d * 0.05)})`; ctx.fillRect((i - 1) * cellW, (j - 1) * cellH, cellW+1, cellH+1); } } }
                ctx.fillStyle = "rgba(255,255,255,0.7)"; ctx.textAlign = "center"; ctx.fillText("DRAG MOUSE TO ADD SMOKE", this.w/2, 50);
            }
        }

        // 6. AUDIO VISUALIZER (ENHANCED)
        class VisualizerEffect {
            constructor(w, h, audioEl) { 
                this.w = w; this.h = h; 
                this.audio = audioEl;
                this.ctx = null; this.analyser = null; this.dataArray = null;
                this.connected = false;
                this.simulated = false; 
                this.init(); 
            }
            init() {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!this.ctx && AudioContext) {
                        this.ctx = new AudioContext();
                        this.analyser = this.ctx.createAnalyser();
                        this.analyser.fftSize = 256;
                        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                        
                        // Handle potential source errors gracefully
                        try {
                            const source = this.ctx.createMediaElementSource(this.audio);
                            source.connect(this.analyser);
                            this.analyser.connect(this.ctx.destination);
                            this.connected = true;
                        } catch(e) {
                            console.log("Source connection error (likely CORS):", e);
                            this.simulated = true;
                        }
                    }
                } catch(e) {
                    this.simulated = true;
                }
            }
            resize(w, h) { this.w=w; this.h=h; }
            update(mouse, params) {
                if (this.audio.paused) return;
                
                if (this.connected && !this.simulated) {
                    try {
                        this.analyser.getByteFrequencyData(this.dataArray);
                        // Auto-switch to simulation if silence detected (CORS block results in 0s)
                        let sum = 0; 
                        for(let i=0; i<this.dataArray.length; i++) sum += this.dataArray[i];
                        if (sum === 0 && !this.audio.paused) this.simulated = true; 
                    } catch(e) { this.simulated = true; }
                }
            }
            draw(ctx, params) {
                ctx.clearRect(0,0,this.w, this.h);
                const cx = this.w/2; const cy = this.h/2;
                const radius = Math.min(this.w, this.h) * 0.2;
                const bars = 64;
                const step = (Math.PI * 2) / bars;
                const boost = params.boost || 2.0; // Higher default

                for(let i=0; i<bars; i++) {
                    let val = 0;
                    if(this.simulated || !this.connected) {
                        // ENHANCED SIMULATION: Looks like real EQ with jagged peaks
                        const t = Date.now() * 0.005;
                        // Combine varied sine waves for "dancing" effect
                        const n = Math.sin(t * (i%10) + i) * Math.cos(t * 0.5 + i*0.2);
                        val = (Math.abs(n) * 50 + 10) * boost;
                        
                        // Beat pulse simulation
                        if(Math.floor(t * 2) % 2 === 0) val *= 1.2;
                        
                        if(this.audio.paused) val = 5; 
                    } else {
                        // Real data (typically 0-255)
                        // Map 64 bars to first ~100 bins of frequency data for bass/mid focus
                        const index = Math.floor(i * (this.dataArray.length / bars)); 
                        val = this.dataArray[index] * 0.5 * boost;
                    }

                    const h = Math.max(5, val * 2);
                    const angle = i * step;
                    
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(angle);
                    
                    // Rainbow hue cycle
                    const hue = i * 5 + Date.now()*0.1;
                    ctx.fillStyle = `hsl(${hue}, 80%, 60%)`;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = `hsl(${hue}, 80%, 60%)`;
                    
                    ctx.beginPath();
                    // Draw outer bar
                    ctx.roundRect(0, radius, 8, h, 4);
                    ctx.fill();
                    
                    ctx.restore();
                }
                
                // Dynamic Center Pulse
                let bass = 0;
                if(this.connected && !this.simulated) bass = this.dataArray[2] || 0;
                else bass = (Math.sin(Date.now()*0.02)+1)*40;
                
                ctx.beginPath();
                ctx.arc(cx, cy, radius * 0.8 + bass * 0.3 * (boost/2), 0, Math.PI*2);
                ctx.fillStyle = `rgba(99, 102, 241, 0.3)`;
                ctx.fill();
                
                ctx.fillStyle = "rgba(255,255,255,0.5)"; ctx.textAlign = "center"; ctx.font = "12px monospace";
                const modeText = this.simulated ? "SIMULATED MODE (CORS)" : "REALTIME AUDIO";
                if(this.audio.paused) ctx.fillText("AUDIO PAUSED", this.w/2, this.h/2 + 5);
                else ctx.fillText(modeText, this.w/2, this.h/2 + 5);
            }
        }

        // --- MAIN COMPONENT ---
        const ImmersiveLab = () => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            
            // State
            const [activeEffect, setActiveEffect] = useState('raycaster');
            const [params, setParams] = useState({});
            const [showUI, setShowUI] = useState(true);
            const [stats, setStats] = useState({ fps: 0 });
            const [hasStarted, setHasStarted] = useState(false); 
            const [isMuted, setIsMuted] = useState(false);
            const [targetFps, setTargetFps] = useState(60);
            
            const bgmRef = useRef(null);
            const sfxRef = useRef(null);
            const animationRef = useRef(null);
            const effectInstance = useRef(null);
            const lastDrawTimeRef = useRef(0);
            const mouse = useRef({ x: 0, y: 0, isDown: false, px: 0, py: 0, click: false });
            const paramsRef = useRef(params);

            // Params Init
            useEffect(() => {
                const initialParams = {};
                const config = DEFAULT_PARAMS[activeEffect];
                if (config) {
                    Object.keys(config).forEach(key => initialParams[key] = config[key].value);
                    setParams(initialParams);
                }
            }, [activeEffect]);

            useEffect(() => { paramsRef.current = params; }, [params]);

            const handleParamChange = (key, value) => setParams(prev => ({ ...prev, [key]: value }));

            // Audio & Visibility
            useEffect(() => {
                const handleVis = () => {
                    if (document.hidden) bgmRef.current?.pause();
                    else if (hasStarted && !isMuted) {
                        bgmRef.current?.play().catch(()=>{});
                        // Resume context just in case
                        if (effectInstance.current && effectInstance.current.ctx && effectInstance.current.ctx.state === 'suspended') {
                            effectInstance.current.ctx.resume();
                        }
                    }
                };
                document.addEventListener("visibilitychange", handleVis);
                return () => document.removeEventListener("visibilitychange", handleVis);
            }, [hasStarted, isMuted]);

            const handleStartApp = () => {
                sfxRef.current?.play().catch(()=>{});
                bgmRef.current?.play().catch(()=>{});
                
                // Initialize Visualizer logic if needed
                if(activeEffect === 'visualizer' && effectInstance.current) {
                    effectInstance.current.init();
                    if (effectInstance.current.ctx && effectInstance.current.ctx.state === 'suspended') {
                        effectInstance.current.ctx.resume();
                    }
                }
                setHasStarted(true);
            };

            const toggleMute = () => {
                if (bgmRef.current) {
                    bgmRef.current.muted = !isMuted;
                    setIsMuted(!isMuted);
                }
            };

            // Main Loop
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const container = containerRef.current;
                
                let w = container.clientWidth; let h = container.clientHeight;
                canvas.width = w; canvas.height = h;

                const loadEffect = () => {
                    switch(activeEffect) {
                        case 'raycaster': effectInstance.current = new RaycasterEffect(w, h); break;
                        case 'starfield': effectInstance.current = new StarfieldEffect(w, h); break;
                        case 'tunnel': effectInstance.current = new TunnelEffect(w, h); break;
                        case 'ripples': effectInstance.current = new RippleEffect(w, h); break;
                        case 'fluid': effectInstance.current = new FluidEffect(w, h); break;
                        case 'visualizer': effectInstance.current = new VisualizerEffect(w, h, bgmRef.current); break;
                        default: effectInstance.current = new RaycasterEffect(w, h);
                    }
                };
                loadEffect();

                // Handle Context Resume on switching
                if(activeEffect === 'visualizer' && hasStarted && effectInstance.current) {
                    effectInstance.current.init();
                    if(effectInstance.current.ctx && effectInstance.current.ctx.state === 'suspended') {
                        effectInstance.current.ctx.resume();
                    }
                }

                const handleResize = () => {
                    w = container.clientWidth; h = container.clientHeight;
                    canvas.width = w; canvas.height = h;
                    effectInstance.current?.resize(w, h);
                };

                const handleMove = (e) => {
                    const rect = canvas.getBoundingClientRect();
                    let clientX = e.clientX;
                    let clientY = e.clientY;
                    if (e.touches && e.touches.length > 0) {
                        clientX = e.touches[0].clientX;
                        clientY = e.touches[0].clientY;
                    }
                    if (clientX !== undefined) {
                        const cx = clientX - rect.left;
                        const cy = clientY - rect.top;
                        mouse.current.px = mouse.current.x; mouse.current.py = mouse.current.y;
                        mouse.current.x = cx; mouse.current.y = cy;
                    }
                };
                const handleDown = (e) => { mouse.current.isDown = true; mouse.current.click = true; handleMove(e); };
                const handleUp = () => { mouse.current.isDown = false; };

                window.addEventListener('resize', handleResize);
                canvas.addEventListener('mousemove', handleMove);
                canvas.addEventListener('mousedown', handleDown);
                canvas.addEventListener('mouseup', handleUp);
                canvas.addEventListener('touchmove', handleMove, {passive:false});
                canvas.addEventListener('touchstart', handleDown, {passive:false});
                canvas.addEventListener('touchend', handleUp);

                let frameCount = 0; let lastTime = performance.now();

                const animate = (time) => {
                    animationRef.current = requestAnimationFrame(animate);
                    if (!effectInstance.current) return;
                    
                    const fpsInterval = 1000 / targetFps;
                    const elapsed = time - lastDrawTimeRef.current;
                    
                    if (elapsed > fpsInterval) {
                        lastDrawTimeRef.current = time - (elapsed % fpsInterval);
                        frameCount++;
                        if (time - lastTime >= 1000) { setStats({ fps: frameCount }); frameCount = 0; lastTime = time; }
                        
                        effectInstance.current.update(mouse.current, paramsRef.current);
                        effectInstance.current.draw(ctx, paramsRef.current);
                        mouse.current.click = false;
                    }
                };
                animationRef.current = requestAnimationFrame(animate);

                return () => {
                    cancelAnimationFrame(animationRef.current);
                    window.removeEventListener('resize', handleResize);
                    canvas.removeEventListener('mousemove', handleMove);
                    canvas.removeEventListener('mousedown', handleDown);
                    canvas.removeEventListener('mouseup', handleUp);
                    canvas.removeEventListener('touchmove', handleMove);
                    canvas.removeEventListener('touchstart', handleDown);
                    canvas.removeEventListener('touchend', handleUp);
                };
            }, [activeEffect, targetFps]);

            const canvasStyle = (activeEffect === 'raycaster' || activeEffect === 'fluid') ? { imageRendering: 'pixelated' } : {};
            
            return (
                <div className="w-full h-[100dvh] relative overflow-hidden bg-slate-900 font-sans text-white">
                    {/* Audio with crossOrigin */}
                    <audio ref={bgmRef} crossOrigin="anonymous" loop src="https://cdn.pixabay.com/download/audio/2022/03/21/audio_0c4867c016.mp3?filename=future-chill_awareness-99187.mp3" />
                    <audio ref={sfxRef} src="https://cdn.pixabay.com/download/audio/2025/06/14/audio_3045825a0d.mp3?filename=sample_confirm_success02_kofi_by_miraclei-360154.mp3" />

                    <div ref={containerRef} className="absolute inset-0 bg-transparent z-0">
                        <canvas ref={canvasRef} style={canvasStyle} className="block w-full h-full touch-none" />
                    </div>

                    {!hasStarted && (
                        <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/70 backdrop-blur-sm transition-opacity duration-500 p-4">
                            <div className="text-center space-y-8 animate-in fade-in zoom-in duration-700 w-full max-w-lg">
                                <h1 className="text-4xl md:text-6xl font-black bg-gradient-to-r from-indigo-400 via-purple-400 to-pink-400 bg-clip-text text-transparent drop-shadow-lg">
                                    IMMERSIVE LAB
                                </h1>
                                <p className="text-slate-300 tracking-widest uppercase text-sm md:text-lg">3D • Fluid • Audio</p>
                                <button onClick={handleStartApp} className="group relative px-8 py-4 bg-transparent overflow-hidden rounded-full border border-white/30 hover:border-white/80 transition-all hover:scale-105 active:scale-95">
                                    <div className="absolute inset-0 w-0 bg-white transition-all duration-[250ms] ease-out group-hover:w-full opacity-10"></div>
                                    <div className="flex items-center space-x-3 text-white justify-center">
                                        <IconPlay className="fill-white" />
                                        <span className="text-xl font-bold tracking-wider">ENTER</span>
                                    </div>
                                </button>
                            </div>
                        </div>
                    )}

                    <div className={`absolute top-0 left-0 h-[100dvh] w-full sm:w-80 bg-slate-900/95 backdrop-blur-md border-r border-slate-700 z-20 transition-transform duration-300 transform ${showUI && hasStarted ? 'translate-x-0' : '-translate-x-full'} flex flex-col shadow-2xl`}>
                        <div className="p-5 md:p-6 shrink-0 flex justify-between items-center">
                            <div>
                                <h1 className="text-xl font-bold bg-gradient-to-r from-indigo-400 to-purple-500 bg-clip-text text-transparent">Immersive Lab</h1>
                                <p className="text-[10px] text-slate-400">Advanced Canvas Experiments</p>
                            </div>
                            <button onClick={() => setShowUI(false)} className="sm:hidden p-2 text-slate-400 hover:text-white">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                            </button>
                        </div>

                        <div className="flex-1 overflow-y-auto px-5 md:px-6 custom-scrollbar pb-6">
                            <nav className="space-y-2 pb-6">
                                <h3 className="text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-2">Pseudo-3D</h3>
                                <button onClick={() => { setActiveEffect('raycaster'); if(window.innerWidth < 640) setShowUI(false); }} className={`w-full flex items-center p-3 rounded-lg transition-colors ${activeEffect === 'raycaster' ? 'bg-indigo-600' : 'hover:bg-slate-800'}`}>
                                    <IconCube className="mr-3 shrink-0" /> <span>Raycaster Maze</span>
                                </button>
                                <button onClick={() => { setActiveEffect('starfield'); if(window.innerWidth < 640) setShowUI(false); }} className={`w-full flex items-center p-3 rounded-lg transition-colors ${activeEffect === 'starfield' ? 'bg-indigo-600' : 'hover:bg-slate-800'}`}>
                                    <IconStar className="mr-3 shrink-0" /> <span>Starfield</span>
                                </button>
                                <button onClick={() => { setActiveEffect('tunnel'); if(window.innerWidth < 640) setShowUI(false); }} className={`w-full flex items-center p-3 rounded-lg transition-colors ${activeEffect === 'tunnel' ? 'bg-indigo-600' : 'hover:bg-slate-800'}`}>
                                    <IconCircle className="mr-3 shrink-0" /> <span>Tunnel</span>
                                </button>
                                
                                <h3 className="text-[10px] font-bold text-slate-500 uppercase tracking-wider mb-2 mt-4">Fluid & Audio</h3>
                                <button onClick={() => { setActiveEffect('ripples'); if(window.innerWidth < 640) setShowUI(false); }} className={`w-full flex items-center p-3 rounded-lg transition-colors ${activeEffect === 'ripples' ? 'bg-cyan-600' : 'hover:bg-slate-800'}`}>
                                    <IconDroplet className="mr-3 shrink-0" /> <span>Water Ripples</span>
                                </button>
                                <button onClick={() => { setActiveEffect('fluid'); if(window.innerWidth < 640) setShowUI(false); }} className={`w-full flex items-center p-3 rounded-lg transition-colors ${activeEffect === 'fluid' ? 'bg-cyan-600' : 'hover:bg-slate-800'}`}>
                                    <IconWind className="mr-3 shrink-0" /> <span>Fluid Smoke</span>
                                </button>
                                <button onClick={() => { setActiveEffect('visualizer'); if(window.innerWidth < 640) setShowUI(false); }} className={`w-full flex items-center p-3 rounded-lg transition-colors ${activeEffect === 'visualizer' ? 'bg-pink-600' : 'hover:bg-slate-800'}`}>
                                    <IconMusic className="mr-3 shrink-0" /> <span>Audio Spectrum</span>
                                </button>
                            </nav>

                            {Object.keys(params).length > 0 && (
                                <div className="mb-6 border-t border-slate-700 pt-5">
                                    <div className="flex items-center gap-2 mb-4 text-slate-300">
                                        <IconSliders size={14} />
                                        <h3 className="text-[10px] font-bold uppercase tracking-wider">Adjustments</h3>
                                    </div>
                                    <div className="space-y-4">
                                        {Object.entries(params).map(([key, val]) => {
                                            const config = DEFAULT_PARAMS[activeEffect][key];
                                            if (!config) return null;
                                            return (
                                                <div key={key} className="space-y-1">
                                                    <div className="flex justify-between text-xs text-slate-400">
                                                        <span>{config.label}</span>
                                                        <span className="font-mono text-cyan-400">{Number(val).toFixed(2)}</span>
                                                    </div>
                                                    <input type="range" min={config.min} max={config.max} step={(config.max - config.min)/100} value={val} onChange={(e) => handleParamChange(key, parseFloat(e.target.value))} className="w-full h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-cyan-500 hover:accent-cyan-400 touch-pan-x" />
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            )}
                        </div>

                        <div className="p-5 md:p-6 bg-slate-900 border-t border-slate-700 shrink-0 space-y-4">
                            <button onClick={toggleMute} className="flex items-center space-x-2 text-xs text-slate-400 hover:text-white transition-colors w-full p-2 rounded hover:bg-slate-800">
                                {isMuted ? <IconVolumeX size={16} /> : <IconVolume2 size={16} />}
                                <span>{isMuted ? "Sound Off" : "Sound On"}</span>
                            </button>
                            <div className="space-y-1">
                                <div className="flex justify-between items-center text-xs text-slate-400">
                                    <span className="flex items-center gap-1"><IconSettings size={12} /> Target FPS</span>
                                    <span className="font-mono text-cyan-400">{targetFps}</span>
                                </div>
                                <input type="range" min={15} max={120} step={15} value={targetFps} onChange={(e) => setTargetFps(Number(e.target.value))} className="w-full h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-cyan-500" />
                            </div>
                            <div className="text-[10px] text-slate-500 pt-1 flex justify-between">
                                <span>FPS:</span>
                                <span className={`font-mono ${stats.fps < targetFps - 5 ? 'text-red-400' : 'text-green-400'}`}>{stats.fps}</span>
                            </div>
                        </div>
                    </div>

                    {hasStarted && (
                        <button onClick={() => setShowUI(!showUI)} className="absolute top-4 left-4 z-30 bg-slate-800/80 p-2.5 rounded-lg hover:bg-slate-700 text-white backdrop-blur-sm transition-opacity shadow-lg">
                            {showUI ? 'Close' : 'Menu'}
                        </button>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ImmersiveLab />);
    </script>
</body>
</html>